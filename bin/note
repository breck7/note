#!/usr/bin/env node
/** 
 * Keeping a large corpus of Note files up to date with the latest
 * encoding, such as blocks, or making mass numbers of changes to the content
 * can be a pain as the number of files increases.
 *
 * This is a global find/replace utility for Note that makes it easy to
 * manage a large number of Notes.
 *
 * Takes a job, written in Note, and applies to a directory(ies).
 *
 * Synchronous.
 * 
 ***/

var fs = require("fs"),
    exec = require('child_process').exec,
    os = require('os'),
    Note = require("note"),
    _ = require("underscore"),
    path = require('path')

var args = process.argv.slice(2)

// Require that a filename is provided
if (args.length < 1) {
  console.log('No filename provided. Usage: note job.note')
  process.exit(1)
}

// Resolve the absolute jobPath to allow for things like ~/job.note
var jobPath = path.resolve(args[0])

// Require that the file exists
if (!fs.existsSync(jobPath)) {
  console.log('File ' + jobPath + ' does not exist.')
  process.exit(1)
}

// Read the file
var jobFile = fs.readFileSync(jobPath, 'utf8')

// Require that the file was read & has content
if (!jobFile) {
  console.log('Empty file or trouble reading it.')
  process.exit(1)
}

function Job(note) {
  if (note)
   this.patch(note)
}

Job.prototype = new Note()
Job.prototype.matches = new Note()
Job.prototype.misses = new Note()
Job.prototype.extension = 'note'

Job.prototype.dir = function (dir) {
  if (this.ondir)
    eval(this.ondir(dir))

  // recursively find all files that match path
  var files = fs.readdirSync(path)
  files = _.map(files, function (file) {return path + '/' + file})
  _.each(files, this.file, this)

}

Job.prototype.complete = function () {
  if (this.oncomplete)
    eval(this.oncomplete())
  
  if (this.saveAs)
    fs.writeFileSync(path.resolve(this.saveAs), this.matches.toString(), 'utf8')
  
  if (this.quiet !== 'true') {
    console.log(this.matches.toString())
    console.log('Job complete.')
  }
}

Job.prototype.file = function (file) {
  if (this.onfile)
    eval(this.onfile(file))
  
  if (this.recursive === 'true') {
    if (fs.statSync(file).isDirectory())
      return this.dir(file)
  }
  
  if (!file.match(this.filenameRegex))
    return false

  var content = fs.readFileSync(file, 'utf8')
  
  // todo: add dumb text find/replace ability.
  
  var note = new Note(content)
  var match = note.get(this.query)
  if (match)
    this.match(file, note, match)
  else
    this.miss(file, note)
  
}

Job.prototype.match = function (file, note, match) {
  
  this.matches[file] = match
  
  if (!this.onmatch)
    return false
  fs.writeFileSync(file, this.onmatch(note).toString(), 'utf8')
}

Job.prototype.miss = function (file, note) {
  
  this.misses[file] = 'miss'
  
  if (this.onmiss)
    this.onmiss(file)
}

Job.prototype.prepare = function () {

  this._paths = this.paths.split(/ /)
  this.filenameRegex =  new RegExp('\.' + this.extension + '$', 'i')
  this.searchRegex = new RegExp(this.query, 'g')
  
  if (this.onmatch)
    eval('this.onmatch = function (note) { ' + this.onmatch + '; return note }')
  
  if (this.onmiss)
    eval('this.onmiss = function (file) { ' + this.onmiss + '; return file }')

  

}

Job.prototype.start = function () {
  
  if (this.quiet !== 'true')
    console.log('Starting job...')
  
  if (this.onstart)
    eval(this.onstart)
  
  _.each(this._paths, this.dir, this)
  
}

Job.prototype.validate = function () {
  
  if (!this.paths) {
    console.log('Provide a path.')
    process.exit(1)
  }
  
  if (!this.query) {
    console.log('Provide a query.')
    process.exit(1)
  }
  
}


var job = new Job(jobFile)
job.validate()
job.prepare()
job.start()
job.complete()
process.exit(0)


